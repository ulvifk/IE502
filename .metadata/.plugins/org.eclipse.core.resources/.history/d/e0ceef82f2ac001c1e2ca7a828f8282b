import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;

import javax.print.attribute.HashAttributeSet;

public class Network {
	Random random = new Random(0);
	private double droneEligableProbability = 0.7;
	
	private ArrayList<Node> C;
	private ArrayList<Drone> V;
	private HashMap<Drone, ArrayList<Node>> CDrone;
	private ArrayList<Node> N;
	private ArrayList<Node> NPlus;
	private ArrayList<Node> N0;
	
	private Vehicle vehicle;
	private Node startingDepot;
	private Node endingDepot;
	
	private double fixedTruckServiceTime = 30;
	private double fixedDroneLaunchTime = 60;
	private double fixedDroneRetrievalTime = 30;
	private double fixedDroneServiceTime = 60;
	
	public Network(int droneLimit) throws IOException {
		this.V = new ArrayList<>();
		populateDrones(droneLimit);
		
		this.C = new ArrayList<>();
		this.CDrone = new HashMap();
		for(Drone v : this.V) {
			this.CDrone.put(v, new ArrayList<Node>());
		}
		this.N = new ArrayList();
		this.NPlus = new ArrayList();
		this.N0 = new ArrayList();
		this.vehicle = new Vehicle(sumParcelWeight());
		
		readDataPoints();
		randomServiceTimeGeneration();
		int x = 0;
	}
	
	private int sumParcelWeight() {
		int sum = 0;
		for(Node node : this.C) {
			sum += node.getParcelVolume();
		}
		
		return sum;
	}
	
	private void randomServiceTimeGeneration() {
		for(Drone v: this.V) {
			this.startingDepot.setDroneLaunchTime(v, fixedDroneLaunchTime);
		}
		for(Drone v: this.V) {
			this.endingDepot.setDroneRetrievalTime(v, fixedDroneRetrievalTime);
		}
		
		for(Node i : this.C) {
			i.setTruckServiceTime(this.fixedTruckServiceTime);
			for(Drone v : this.V) {
				i.setDroneLaunchTime(v, fixedDroneLaunchTime);
				i.setDroneRetrievalTime(v, fixedDroneLaunchTime);
				i.setDroneServiceTime(v, this.fixedDroneServiceTime);
			}
		}
		
		
		for(Drone v : this.V) {
			for(Node i : this.CDrone.get(v)) {
				i.setDroneLaunchTime(v, this.fixedDroneLaunchTime);
				i.setDroneRetrievalTime(v, this.fixedDroneRetrievalTime);
				i.setDroneServiceTime(v, this.fixedDroneServiceTime);
			}
		}
	}
	
	private void populateDrones(int droneLimit) {
		for(int i = 0; i<droneLimit; i++) {
			Drone drone = new Drone(i, 0.5, 70);
			this.V.add(drone);
		}
	}
	
	private void readDataPoints() throws IOException {
		BufferedReader br = new BufferedReader(new FileReader("C:\\IE502QGIS\\Jupyter\\deneme.csv"));
		String line = "";
		
		double droneEligableParcelMean = 2;
		double droneEligableParcelDeviation = 2;
		
		double nonDroneEligableParcelMean = 6;
		double nonDroneEligableParcelDeviaton = 5;
		
		line = br.readLine();
		line = br.readLine();
		String[] tokens = line.split(",");
		Position depotPos = new Position(Double.parseDouble(tokens[1]), Double.parseDouble(tokens[2]));
		Node startDepot = new Node(Type.TRUCK, 0, depotPos, 0);
		Node endDepot = new Node(Type.TRUCK, 0, depotPos, 0);
		
		this.N.add(startDepot);
		this.N.add(endDepot);
		
		this.NPlus.add(endDepot);
		this.N0.add(startDepot);
		
		this.startingDepot = startDepot;
		this.endingDepot = endDepot;
		
		while((line = br.readLine()) != null) {
			tokens = line.split(",");
			Position pos = new Position(Double.parseDouble(tokens[1]), Double.parseDouble(tokens[2]));	
			
			Type nodeType = null;
			double parcelVolume = 0;
			
			if(this.random.nextDouble() < this.droneEligableProbability) {
				nodeType = Type.UAVELIGIBLE;
				parcelVolume = (this.random.nextGaussian() + droneEligableParcelMean) * droneEligableParcelDeviation;
				Node node = new Node(nodeType, Integer.parseInt(tokens[0]), pos, parcelVolume);
				
				this.C.add(node);
				for(Drone v : this.V) {
					this.CDrone.get(v).add(node);
				}
				this.N.add(node);
				this.NPlus.add(node);
				this.N0.add(node);
			}
			else {
				nodeType = Type.TRUCK;
				parcelVolume = (this.random.nextGaussian() + nonDroneEligableParcelMean) * nonDroneEligableParcelDeviaton;
				Node node = new Node(nodeType, Integer.parseInt(tokens[0]), pos, parcelVolume);
				
				this.C.add(node);
				this.N.add(node);
				this.NPlus.add(node);
				this.N0.add(node);
			}
		}
	}
	
	private void readNodeInformation() throws IOException {
		BufferedReader br = new BufferedReader(new FileReader("C:\\IE502QGIS\\Jupyter\\JavaData\\NodeInformation.csv"));
		String line = "";
		
		line = br.readLine();
		line = br.readLine();
		String[] tokens = line.split(",");
		Position depotPos = new Position(Double.parseDouble(tokens[1]), Double.parseDouble(tokens[2]));
		Node startDepot = new Node(Type.TRUCK, 0, depotPos, 0);
		Node endDepot = new Node(Type.TRUCK, 0, depotPos, 0);
		
		this.N.add(startDepot);
		this.N.add(endDepot);
		
		this.NPlus.add(endDepot);
		this.N0.add(startDepot);
		
		this.startingDepot = startDepot;
		this.endingDepot = endDepot;
		
		while((line = br.readLine()) != null) {
			tokens = line.split(",");
			Position pos = new Position(Double.parseDouble(tokens[2]), Double.parseDouble(tokens[3]));	
			Node node = new Node(tokens[4], tokens[1], pos, tokens[5]);
		}
	}
	
	private void readDistanceMatrix() {
	}
	// Getter setters.
	public ArrayList<Node> getC() {
		return C;
	}

	public ArrayList<Drone> getV() {
		return V;
	}

	public HashMap<Drone, ArrayList<Node>> getCDrone() {
		return CDrone;
	}

	public ArrayList<Node> getN() {
		return N;
	}

	public ArrayList<Node> getNPlus() {
		return NPlus;
	}

	public ArrayList<Node> getN0() {
		return N0;
	}

	public Vehicle getVehicle() {
		return vehicle;
	}

	public Node getStartingDepot() {
		return startingDepot;
	}

	public Node getEndingDepot() {
		return endingDepot;
	}

	
}
